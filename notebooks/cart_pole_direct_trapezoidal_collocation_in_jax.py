# -*- coding: utf-8 -*-
"""Cart-Pole Direct Trapezoidal Collocation in JAX

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kpZqqVTGDQ5BPaEkZMF2sVlBAw_eMgU7
"""

# Commented out IPython magic to ensure Python compatibility.
from functools import partial

import jax
from jax import grad, jit, vmap, jacrev
from jax.config import config
from jax.flatten_util import ravel_pytree
import jax.numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import numpy as onp
import seaborn as sns
from scipy.optimize import minimize

config.update("jax_enable_x64", True)
# %config InlineBackend.figure_format = 'retina'

# Physical parameters for the cart-pole example (Table 3)
m1 = 1.0 #kg mass of cart
m2 = 0.3 #kg mass of pole
l = 0.5 #m pole length
g = 9.81 #m/s^2 gravity acceleration
u_max = 20 #N maximum actuator force
d_max = 2.0 #m extent of the rail that cart travels on
d = 1.0 #m distance traveled during swing-up
T = 2.0 #s duration of swing-up
x_0 = np.zeros(4) # State at time 0
x_T = np.array([d,np.pi,0,0]) # State at time T

# Cart-Pole Example: System Dynamics (Section 6.1)
def dynamics(x_t: np.ndarray, u_t: np.float64) -> np.ndarray:
  q1, q2, q̇1, q̇2 = x_t
  # Eq. 6.1
  q̈1 = (l * m2 * np.sin(q2) * q̇2**2 + u_t + m2 * g * np.cos(q2) * np.sin(q2)) / (m1 + m2 * (1 - np.cos(q2)**2))
  q̈1 = np.squeeze(q̈1)
  # Eq. 6.2
  q̈2 = - (l * m2 * np.cos(q2) * q̇2**2 + u_t * np.cos(q2) + (m1 + m2) * g * np.sin(q2)) / (l * m1 + l * m2 * (1 - np.cos(q2)**2))
  q̈2 = np.squeeze(q̈2)
  return np.array([q̇1, q̇2, q̈1, q̈2])

def cost(x_t: np.ndarray, u_t: np.float64) -> np.float64:
  # Eq. 6.3
  return u_t ** 2

# Trapezoidal collocation parameters
N = 25 # Segments
h = T/N # Segment length

# Initial collocation guess
x_guess = np.linspace(x_0, 1, num=N+1) * x_T
u_guess = np.zeros((N+1,1))
guess, unravel = ravel_pytree(np.hstack((x_guess, u_guess)))

# Shared code for objective and constraint
def _shared(fn, reduce, variables: np.ndarray):
  xu = unravel(variables)
  x, u = xu[:,:4], xu[:,4:]
  return reduce(vmap(fn)(x[:-1], x[1:], u[:-1], u[1:]))

# Objective (Eq. 6.4)
def objective_t(x_t1: np.ndarray, x_t2: np.ndarray, u_t1: np.float64, u_t2: np.float64) -> np.float64:
  return (h/2) * (cost(x_t1, u_t1) + cost(x_t2, u_t2))
objective = partial(_shared, objective_t, np.sum)

# Collocation Constraints (Eq. 6.6)
def defect_t(x_t1: np.ndarray, x_t2: np.ndarray, u_t1: np.float64, u_t2: np.float64) -> np.ndarray:
  left = (h/2) * (dynamics(x_t1, u_t1) + dynamics(x_t2, u_t2))
  right = x_t2 - x_t1
  return left - right
defect = partial(_shared, defect_t, np.ravel)

# Path and Boundary Constraints 
# State bounds
bounds = onp.empty((N+1,5,2))
bounds[:,:,:] = onp.nan
bounds[:,0,:] = [-d_max, d_max] # Eq. 6.7
bounds[:,1,:] = [-2*onp.pi, 2*onp.pi]

# Starting state (Eq. 6.9)
bounds[0,:,:] = 0
# Ending state (Eq. 6.9)
bounds[-1,0:4,:] = np.expand_dims(x_T, 1)

# Control bounds (Eq. 6.8)
bounds[:,4,:] = [-u_max, u_max]

# Prepare for scipy.optimize.minimize
bounds = bounds.reshape((-1,2))
bounds = np.array(bounds)

solution = minimize(
  fun=jit(objective),
  x0=guess,
  method='SLSQP',
  constraints=[{
    'type': 'eq',
    'fun': jit(defect),
    'jac': jit(jacrev(defect)),
  }],
  bounds=bounds,
  jac=jit(grad(objective)),
  options={'disp': True},
)

x = unravel(solution.x)
x = pd.DataFrame(x, columns=['q1','q2','q̈1','q̈2','u'])

# Plot optimal trajectory (Figure 10)
sns.set(style='darkgrid')
plt.figure(figsize=(9,6))
ts = np.linspace(0,T,N+1)

plt.subplot(3,1,1)
plt.ylabel('position (m)')
plt.xlim(0,2)
plt.ylim(0,1.5)
plt.plot(ts, x['q1'], '-bo', clip_on=False, zorder=10)

plt.subplot(3,1,2)
plt.ylabel('angle (rad)')
plt.plot(ts, x['q2'], '-bo', clip_on=False, zorder=10)
plt.xlim(0,2)
plt.ylim(-2,4)

plt.subplot(3,1,3)
plt.ylabel('force (N)')
plt.plot(ts, x['u'], '-bo', clip_on=False, zorder=10)
plt.xlim(0,2)
plt.ylim(-20,10)

plt.xlabel('time (s)')
plt.tight_layout()
plt.show()
