<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>myriad.optimizers API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>myriad.optimizers</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from dataclasses import dataclass
import time
from typing import Callable, Tuple, Union, Optional

from jax import grad, jacrev, jit, vmap
from jax.flatten_util import ravel_pytree
from jax.ops import index_update
import jax.numpy as jnp
import numpy as np
from ipopt import minimize_ipopt
from scipy.optimize import minimize

from myriad.config import Config, HParams, OptimizerType, SystemType, NLPSolverType, IntegrationOrder
from myriad.systems import FiniteHorizonControlSystem, IndirectFHCS
from myriad.utils import integrate, integrate_in_parallel, integrate_fbsm
from myriad.nlp_solvers import extra_gradient


@dataclass
class TrajectoryOptimizer(object):
  _type: OptimizerType
  hp: HParams
  cfg: Config
  objective: Callable[[jnp.ndarray], float]
  constraints: Callable[[jnp.ndarray], jnp.ndarray]
  bounds: jnp.ndarray
  guess: jnp.ndarray
  unravel: Callable[[jnp.ndarray], Tuple]
  require_adj: bool = False

  def __post_init__(self):
    # if self.cfg.verbose:
    #   print(f&#34;x_guess.shape = {self.x_guess.shape}&#34;)
    #   print(f&#34;u_guess.shape = {self.u_guess.shape}&#34;)
    #   print(f&#34;guess.shape = {self.guess.shape}&#34;)
    #   print(f&#34;x_bounds.shape = {self.x_bounds.shape}&#34;)
    #   print(f&#34;u_bounds.shape = {self.u_bounds.shape}&#34;)
    #   print(f&#34;bounds.shape = {self.bounds.shape}&#34;)

    if self.hp.system == SystemType.INVASIVEPLANT:
      raise NotImplementedError(&#34;Discrete systems are not compatible with Trajectory optimizers&#34;)

  def solve(self, extra_options=None) -&gt; Tuple[jnp.ndarray, jnp.ndarray]:
    _t1 = time.time()
    options = {&#34;maxiter&#34;: self.hp.max_iter}
    # Merge the two dictionaries, keeping the entry from &#39;extra_options&#39; in the case of a key collision
    if extra_options is not None and self.hp.nlpsolver == NLPSolverType.EXTRAGRADIENT:
      options = {**options, **extra_options}
      print(&#34;loaded extra options&#34;)
    opt_inputs = {
      &#39;fun&#39;: jit(self.objective) if self.cfg.jit else self.objective,
      &#39;x0&#39;: self.guess,
      &#39;constraints&#39;: ({
        &#39;type&#39;: &#39;eq&#39;,
        &#39;fun&#39;: jit(self.constraints) if self.cfg.jit else self.constraints,
        &#39;jac&#39;: jit(jacrev(self.constraints)) if self.cfg.jit else jacrev(self.constraints),
      }),
      &#39;bounds&#39;: self.bounds,
      &#39;jac&#39;: jit(grad(self.objective)) if self.cfg.jit else grad(self.objective),
      &#39;options&#39;: options
    }
    if self.hp.nlpsolver == NLPSolverType.EXTRAGRADIENT:
      del opt_inputs[&#39;jac&#39;]
      solution = extra_gradient(**opt_inputs)
    elif self.hp.nlpsolver == NLPSolverType.SLSQP:
      opt_inputs[&#39;method&#39;] = &#39;SLSQP&#39;
      solution = minimize(**opt_inputs)
    elif self.hp.nlpsolver == NLPSolverType.TRUST:
      opt_inputs[&#39;method&#39;] = &#39;trust-constr&#39;
      solution = minimize(**opt_inputs)
    elif self.hp.nlpsolver == NLPSolverType.IPOPT:
      solution = minimize_ipopt(**opt_inputs)
    else:
      print(&#34;Unknown NLP solver. Please choose among&#34;, list(NLPSolverType.__members__.keys()))
      raise ValueError
    _t2 = time.time()
    if self.cfg.verbose:
      print(&#39;Solver exited with success:&#39;, solution.success)
      print(f&#39;Completed in {_t2 - _t1} seconds.&#39;)

    if self.hp.order == IntegrationOrder.QUADRATIC and self._type == OptimizerType.COLLOCATION:
      x, x_mid, u, u_mid = self.unravel(solution.x)
    else:
      x, u = self.unravel(solution.x)

    return x, u


@dataclass
class IndirectMethodOptimizer(object):
  &#34;&#34;&#34;
  Base class for implementing indirect method optimizers, i.e. optimizers that relies on the Pontryagin&#39;s maximum principle
  &#34;&#34;&#34;
  hp: HParams
  &#34;&#34;&#34;The collection of hyperparameters for the experiment&#34;&#34;&#34;
  cfg: Config
  &#34;&#34;&#34;Configuration options that should not impact results&#34;&#34;&#34;
  bounds: jnp.ndarray
  &#34;&#34;&#34;Bounds (lower, upper) over the state variables, followed by the bounds over the controls&#34;&#34;&#34;
  guess: jnp.ndarray    # Initial guess on x_t, u_t and adj_t
  &#34;&#34;&#34;Initial guess for the state, control and adjoint variables&#34;&#34;&#34;
  unravel: Callable[[jnp.ndarray], Tuple[jnp.ndarray, jnp.ndarray]]
  &#34;&#34;&#34;Callable to unravel the pytree&#34;&#34;&#34;
  require_adj: bool = True
  &#34;&#34;&#34;(bool, optional) -- &#34;&#34;&#34;

  def solve(self) -&gt; Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:
    &#34;&#34;&#34;Solve method&#34;&#34;&#34;
    raise NotImplementedError

  def stopping_criterion(self, x_iter: Tuple[jnp.ndarray, jnp.ndarray], u_iter: Tuple[jnp.ndarray, jnp.ndarray],
                         adj_iter: Tuple[jnp.ndarray, jnp.ndarray], delta: float = 0.001) -&gt; bool:
    &#34;&#34;&#34;
    Criterion for stopping the optimization iterations.
    &#34;&#34;&#34;
    x, old_x = x_iter
    u, old_u = u_iter
    adj, old_adj = adj_iter

    stop_x = jnp.abs(x).sum(axis=0) * delta - jnp.abs(x - old_x).sum(axis=0)
    stop_u = jnp.abs(u).sum(axis=0)*delta - jnp.abs(u-old_u).sum(axis=0)
    stop_adj = jnp.abs(adj).sum(axis=0) * delta - jnp.abs(adj - old_adj).sum(axis=0)

    return jnp.min(jnp.hstack((stop_u, stop_x, stop_adj))) &lt; 0


def get_optimizer(hp: HParams, cfg: Config, system: Union[FiniteHorizonControlSystem, IndirectFHCS]
                  ) -&gt; Union[TrajectoryOptimizer, IndirectMethodOptimizer]:
  &#34;&#34;&#34; Helper function to fetch the desired optimizer for system resolution&#34;&#34;&#34;
  if hp.optimizer == OptimizerType.COLLOCATION:
    if hp.order == IntegrationOrder.CONSTANT:
      print(&#34;CONSTANT collocation not yet implemented; using LINEAR collocation for now&#34;)
      optimizer = TrapezoidalCollocationOptimizer(hp, cfg, system)
    elif hp.order == IntegrationOrder.LINEAR:
      optimizer = TrapezoidalCollocationOptimizer(hp, cfg, system)
    else:  # Quadratic
      optimizer = HermiteSimpsonCollocationOptimizer(hp, cfg, system)
  elif hp.optimizer == OptimizerType.SHOOTING:
    optimizer = MultipleShootingOptimizer(hp, cfg, system)
  elif hp.optimizer == OptimizerType.FBSM:
    optimizer = FBSM(hp, cfg, system)
  else:
    raise KeyError
  return optimizer


class TrapezoidalCollocationOptimizer(TrajectoryOptimizer):
  def __init__(self, hp: HParams, cfg: Config, system: FiniteHorizonControlSystem):
    num_intervals = hp.intervals  # Segments
    h = system.T / num_intervals  # Segment length
    state_shape = system.x_0.shape[0]
    control_shape = system.bounds.shape[0] - state_shape

    u_guess = jnp.zeros((num_intervals+1, control_shape))
    u_mean = system.bounds[-1 * control_shape:].mean()

    if (not jnp.isnan(jnp.sum(u_mean))) and (not jnp.isinf(u_mean).any()):  # handle bounds with infinite values
      u_guess += u_mean

    if system.x_T is not None:
      # We need to handle the cases where a terminal bound is specified only for some state variables, not all
      row_guesses = []
      for i in range(0, len(system.x_T)):
        if system.x_T[i] is not None:
          row_guess = jnp.linspace(system.x_0[i], system.x_T[i], num=num_intervals+1).reshape(-1, 1)
        else:
          _, row_guess = integrate(system.dynamics, system.x_0, u_guess, h, num_intervals, None, hp.order)
          row_guess = row_guess[:, i].reshape(-1, 1)
        row_guesses.append(row_guess)
      x_guess = jnp.hstack(row_guesses)
    else:  # no final state requirement
      _, x_guess = integrate(system.dynamics, system.x_0, u_guess, h, num_intervals, None, hp.order)
    guess, unravel_decision_variables = ravel_pytree((x_guess, u_guess))
    self.x_guess, self.u_guess = x_guess, u_guess

    def trapezoid_cost(x_t1: jnp.ndarray, x_t2: jnp.ndarray, u_t1: float, u_t2: float, t1: float, t2: float) -&gt; float:
      return (h/2) * (system.cost(x_t1, u_t1, t1) + system.cost(x_t2, u_t2, t2))

    def objective(variables: jnp.ndarray) -&gt; float:
      x, u = unravel_decision_variables(variables)
      t = jnp.linspace(0, system.T, num=num_intervals+1)  # Support cost function with dependency on t
      cost = jnp.sum(vmap(trapezoid_cost)(x[:-1], x[1:], u[:-1], u[1:], t[:-1], t[1:]))
      if system.terminal_cost:
        cost += jnp.sum(system.terminal_cost_fn(x[-1], u[-1]))
      return cost

    def trapezoid_defect(x_t1: jnp.ndarray, x_t2: jnp.ndarray, u_t1: float, u_t2: float) -&gt; jnp.ndarray:
      left = (h/2) * (system.dynamics(x_t1, u_t1) + system.dynamics(x_t2, u_t2))
      right = x_t2 - x_t1
      return left - right

    def constraints(variables: jnp.ndarray) -&gt; jnp.ndarray:
      x, u = unravel_decision_variables(variables)
      return jnp.ravel(vmap(trapezoid_defect)(x[:-1], x[1:], u[:-1], u[1:]))

    ############################
    # State and Control Bounds #
    ############################
    
    x_bounds = np.empty((num_intervals+1, system.bounds.shape[0]-control_shape, 2))
    x_bounds[:, :, :] = system.bounds[:-control_shape]
    x_bounds[0, :, :] = np.expand_dims(system.x_0, 1)
    if system.x_T is not None:
      x_bounds[-control_shape, :, :] = np.expand_dims(system.x_T, 1)
    x_bounds = x_bounds.reshape((-1, 2))
    u_bounds = np.empty(((num_intervals+1)*control_shape, 2))
    for i in range(control_shape, 0, -1):
      u_bounds[(control_shape-i)*(num_intervals+1):(control_shape-i+1)*(num_intervals+1)] = system.bounds[-i]
    bounds = jnp.vstack((x_bounds, u_bounds))
    self.x_bounds, self.u_bounds = x_bounds, u_bounds

    super().__init__(OptimizerType.COLLOCATION, hp, cfg, objective, constraints, bounds, guess, unravel_decision_variables)


class HermiteSimpsonCollocationOptimizer(TrajectoryOptimizer):

  def __init__(self, hp: HParams, cfg: Config, system: FiniteHorizonControlSystem):
    num_intervals = hp.intervals
    interval_duration = system.T / hp.intervals

    u_guess, mid_u_guess = jnp.ones(num_intervals + 1) * 0.1, jnp.zeros(num_intervals) * 0.1

    # Initial guess for state and controls
    # O . . . O (guess dots)
    if system.x_T is not None:
      full_x_guess = jnp.linspace(system.x_0, system.x_T, num=hp.intervals + 1)

      # make the mid states linear too (interpolate between collocation points)
      mid_x_guess = np.copy((full_x_guess[:-1] + full_x_guess[1:])/2)
      # Now remove the end points from the state guesses
      x_guess = jnp.linspace(system.x_0, system.x_T, num=hp.intervals + 1)[1:-1]
    # O . . . . (guess dots)
    else:
      # _, x_guess = integrate(system.dynamics, system.x_0, u_guess, interval_duration, num_intervals)[1:] # should be right
      x_guess = jnp.ones(shape=(num_intervals, len(system.x_0))) * 0.25
      mid_x_guess = jnp.ones(shape=(num_intervals, len(system.x_0))) * 0.25

    initial_variables = (x_guess, mid_x_guess, u_guess, mid_u_guess)

    guess, unravel_decision_variables = ravel_pytree(initial_variables)
    self.x_guess, self.u_guess = x_guess, u_guess

    ############################
    # State and Control Bounds #
    ############################

    u_bounds = np.empty((num_intervals + 1, 2))
    u_bounds[:] = system.bounds[-1:]

    mid_u_bounds = np.empty((num_intervals, 2))
    mid_u_bounds[:] = system.bounds[-1:]

    single_x_bounds = system.bounds[:-1].flatten()

    if system.x_T is not None:
      x_bounds = jnp.tile(single_x_bounds, reps=(num_intervals - 1, 1))
      mid_x_bounds = jnp.tile(single_x_bounds, reps=(num_intervals, 1))
    else:
      x_bounds = jnp.tile(single_x_bounds, reps=(num_intervals, 1))
      mid_x_bounds = jnp.tile(single_x_bounds, reps=(num_intervals, 1))

    x_bounds = x_bounds.reshape(-1, 2)
    mid_x_bounds = mid_x_bounds.reshape(-1, 2)

    bounds = jnp.vstack((x_bounds, mid_x_bounds, u_bounds, mid_u_bounds))
    self.x_bounds, self.u_bounds = x_bounds, u_bounds

    # Convenience function
    def get_start_and_next_states_and_controls(variables: jnp.ndarray) -&gt; Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray,
                                                                                jnp.ndarray, jnp.ndarray, jnp.ndarray]:
      xs, mid_xs, us, mid_us = unravel_decision_variables(variables)

      if system.x_T is not None:
        starting_states = jnp.concatenate((system.x_0[jnp.newaxis], xs))
        desired_next_states = jnp.concatenate((xs, system.x_T[jnp.newaxis]))
      else:  # last &#34;decision state&#34; is actually final state in this case
        starting_states = jnp.concatenate((system.x_0[jnp.newaxis], xs[:-1]))
        desired_next_states = xs

      return starting_states, mid_xs, desired_next_states, \
             us[:-1],         mid_us, us[1:]

    # Hermite-Simpson collocation constraints (calculates midpoint constraints on-the-fly)
    def hs_defect(state, mid_state, next_state, control, mid_control, next_control):
      rhs = next_state - state
      lhs = (interval_duration / 6) \
          * ( system.dynamics(state, control)
              + 4 * system.dynamics(mid_state, mid_control)
              + system.dynamics(next_state, next_control) )
      return rhs - lhs

    # Hermite-Simpson interpolation constraints
    def hs_interpolation(state, mid_state, next_state, control, mid_control, next_control):
      return (mid_state
              - (1/2) * (state + next_state)
              - (interval_duration/8) * (system.dynamics(state, control) - system.dynamics(next_state, next_control)))

    # This is the &#34;J&#34; from the tutorial (6.5)
    def hs_cost(state, mid_state, next_state, control, mid_control, next_control):
      return (interval_duration/6) \
              * ( system.cost(state, control)
                  + 4 * system.cost(mid_state, mid_control)
                  + system.cost(next_state, next_control) )

    #######################
    # Cost and Constraint #
    #######################
    def objective(variables):
      unraveled_vars = get_start_and_next_states_and_controls(variables)
      return jnp.sum(vmap(hs_cost)(*unraveled_vars))

    def hs_equality_constraints(variables):
      unraveled_vars = get_start_and_next_states_and_controls(variables)
      return jnp.ravel(vmap(hs_defect)(*unraveled_vars))

    def hs_interpolation_constraints(variables):
      unraveled_vars = get_start_and_next_states_and_controls(variables)
      return jnp.ravel(vmap(hs_interpolation)(*unraveled_vars))

    def constraints(variables):
      equality_defects = hs_equality_constraints(variables)
      interpolation_defects = hs_interpolation_constraints(variables)
      return jnp.hstack((equality_defects, interpolation_defects))

    super().__init__(OptimizerType.COLLOCATION, hp, cfg, objective, constraints, bounds, guess, unravel_decision_variables)


class MultipleShootingOptimizer(TrajectoryOptimizer):
  def __init__(self, hp: HParams, cfg: Config, system: FiniteHorizonControlSystem):
    num_steps = hp.intervals * hp.controls_per_interval
    step_size = system.T / num_steps
    interval_size = system.T / hp.intervals
    state_shape = system.x_0.shape[0]
    control_shape = system.bounds.shape[0] - state_shape
    midpoints_const = 2 if hp.order == IntegrationOrder.QUADRATIC else 1

    #################
    # Initial Guess #
    #################

    # Controls
    controls_guess = jnp.zeros((midpoints_const*num_steps + 1, control_shape))
    controls_mean = system.bounds[-1 * control_shape:].mean()
    if (not jnp.isnan(jnp.sum(controls_mean))) and (not jnp.isinf(controls_mean).any()):  # handle bounds with infinite values
      controls_guess += controls_mean

    # States
    if system.x_T is not None:
      row_guesses = []
      # For the state variables which have a required end state, interpolate between start and end;
      # otherwise, use rk4 with initial controls as a first guess at intermediate and end state values
      for i in range(0, len(system.x_T)):
        if system.x_T[i] is not None:
          row_guess = jnp.linspace(system.x_0[i], system.x_T[i], num=hp.intervals+1).reshape(-1, 1)
        else:
          _, row_guess = integrate(system.dynamics, system.x_0, controls_guess[::midpoints_const*hp.controls_per_interval], interval_size, hp.intervals, None, hp.order)
          row_guess = row_guess[:, i].reshape(-1, 1)
        row_guesses.append(row_guess)
      x_guess = jnp.hstack(row_guesses)
    else:
      _, x_guess = integrate(system.dynamics, system.x_0, controls_guess[::midpoints_const*hp.controls_per_interval], interval_size, hp.intervals, None, hp.order)
    guess, unravel = ravel_pytree((x_guess, controls_guess))
    assert len(x_guess) == hp.intervals + 1  # we have one state decision var for each node, including start and end
    self.x_guess, self.u_guess = x_guess, controls_guess

    # Augment the dynamics so we can integrate cost the same way we do state
    def augmented_dynamics(x_and_c: jnp.ndarray, u: float, t: jnp.ndarray) -&gt; jnp.ndarray:
      x, c = x_and_c[:-1], x_and_c[-1]
      return jnp.append(system.dynamics(x, u), system.cost(x, u, t))

    # Go from having controls like (num_controls + 1, control_shape) (left)
    #                      to like (hp.intervals, num_controls_per_interval + 1, control_shape) (right)
    # [ 1. ,  1.1]                [ 1. ,  1.1]
    # [ 2. ,  2.1]                [ 2. ,  2.1]
    # [ 3. ,  3.1]                [ 3. ,  3.1]
    # [ 4. ,  4.1]                [ 4. ,  4.1]
    # [ 5. ,  5.1]
    # [ 6. ,  6.1]                [ 4. ,  4.1]
    # [ 7. ,  7.1]                [ 5. ,  5.1]
    # [ 8. ,  8.1]                [ 6. ,  6.1]
    # [ 9. ,  9.1]                [ 7. ,  7.1]
    # [10. , 10.1]
    #                             [ 7. ,  7.1]
    #                             [ 8. ,  8.1]
    #                             [ 9. ,  9.1]
    #                             [10. , 10.1]
    def reorganize_controls(us):  # This still works, even for higher-order control shape
      new_controls = jnp.hstack([us[:-1].reshape(hp.intervals, midpoints_const*hp.controls_per_interval, control_shape),
                                us[::midpoints_const*hp.controls_per_interval][1:][:, jnp.newaxis]])
      # Needed for single shooting
      if len(new_controls.shape) == 3 and new_controls.shape[2] == 1:
        new_controls = new_controls.squeeze(axis=2)
      return new_controls

    # Same idea as above function, but for the times
    def reorganize_times(ts):
      new_times = jnp.hstack([ts[:-1].reshape(hp.intervals, hp.controls_per_interval),
                             ts[::hp.controls_per_interval][1:][:, jnp.newaxis]])
      return new_times

    def objective(variables: jnp.ndarray) -&gt; float:
      # print(&#34;dynamics are&#34;, system.dynamics)
      # The commented code runs faster, but only does a linear interpolation for cost.
      # Better to have the interpolation match the integration scheme,
      # and just use Euler / Heun if we need shooting to be faster

      # xs, us = unravel(variables)
      # t = jnp.linspace(0, system.T, num=N_x+1)[:-1]  # Support cost function with dependency on t
      # t = jnp.repeat(t, hp.controls_per_interval)
      # _, x = integrate(system.dynamics, system.x_0, u, h_u, N_u)
      # x = x[:-1]
      # if system.terminal_cost:
      #   return jnp.sum(system.terminal_cost_fn(x[-1], u[-1])) + h_u * jnp.sum(vmap(system.cost)(x, u, t))
      # else:
      #   return h_u * jnp.sum(vmap(system.cost)(x, u, t))
      # ---
      xs, us = unravel(variables)
      reshaped_controls = reorganize_controls(us)

      t = jnp.linspace(0., system.T, num=num_steps + 1)
      t = reorganize_times(t)

      starting_xs_and_costs = jnp.hstack([xs[:-1], jnp.zeros(len(xs[:-1])).reshape(-1, 1)])

      # Integrate cost in parallel
      states_and_costs, _ = integrate_in_parallel(
        augmented_dynamics, starting_xs_and_costs, reshaped_controls,
        step_size, hp.controls_per_interval, t, hp.order)

      costs = jnp.sum(states_and_costs[:,-1])
      if system.terminal_cost:
        last_augmented_state = states_and_costs[-1]
        costs += system.terminal_cost_fn(last_augmented_state[:-1], us[-1])

      return costs
    
    def constraints(variables: jnp.ndarray) -&gt; jnp.ndarray:
      xs, us = unravel(variables)
      px, _ = integrate_in_parallel(system.dynamics, xs[:-1], reorganize_controls(us), step_size,
                                    hp.controls_per_interval, None, hp.order)
      return jnp.ravel(px - xs[1:])

    ############################
    # State and Control Bounds #
    ############################

    # State decision variables at every node
    x_bounds = np.zeros((hp.intervals + 1, system.bounds.shape[0] - control_shape, 2))
    x_bounds[:, :, :] = system.bounds[:-control_shape]

    # Starting state
    x_bounds[0, :, :] = jnp.expand_dims(system.x_0, 1)

    # Ending state
    if system.x_T is not None:
      for i in range(len(system.x_T)):
        if system.x_T[i] is not None:
          x_bounds[-1, i, :] = system.x_T[i]

    # Reshape for ipopt&#39;s minimize
    x_bounds = x_bounds.reshape((-1, 2))

    # Control decision variables at every node, and if QUADRATIC order, also at midpoints
    u_bounds = np.empty(((midpoints_const*num_steps + 1) * control_shape, 2)) # Include midpoints too
    for i in range(control_shape, 0, -1):
      u_bounds[(control_shape - i) * (midpoints_const*num_steps + 1):(control_shape - i + 1) * (midpoints_const*num_steps + 1)] = system.bounds[-i]

    # print(&#34;u bounds&#34;, u_bounds)
    # Stack all bounds together for the NLP solver
    bounds = jnp.vstack((x_bounds, u_bounds))
    self.x_bounds, self.u_bounds = x_bounds, u_bounds

    super().__init__(OptimizerType.SHOOTING, hp, cfg, objective, constraints, bounds, guess, unravel)


class FBSM(IndirectMethodOptimizer):  # Forward-Backward Sweep Method
  &#34;&#34;&#34;
  The Forward-Backward Sweep Method, as described in Optimal Control Applied to Biological Models, Lenhart &amp; Workman

  An iterative solver that, given an initial guess over the controls, will do a forward pass to retrieve the state
  variables trajectory followed by a backward pass to retrieve the adjoint variables trajectory. The optimality
  characterization is then used to update the control values.

  The process is repeated until convergence over the controls.
  &#34;&#34;&#34;
  def __init__(self, hp: HParams, cfg: Config, system: IndirectFHCS):
    self.system = system
    self.N = hp.fbsm_intervals
    self.h = system.T / self.N
    if system.discrete:
      self.N = int(system.T)
      self.h = 1
    state_shape = system.x_0.shape[0]
    control_shape = system.bounds.shape[0] - state_shape

    x_guess = jnp.vstack((system.x_0, jnp.zeros((self.N, state_shape))))
    if system.discrete:
      u_guess = jnp.zeros((self.N, control_shape))
    else:
      u_guess = jnp.zeros((self.N+1, control_shape))
    if system.adj_T is not None:
      adj_guess = jnp.vstack((jnp.zeros((self.N, state_shape)), system.adj_T))
    else:
      adj_guess = jnp.zeros((self.N+1, state_shape))
    self.t_interval = jnp.linspace(0, system.T, num=self.N+1).reshape(-1, 1)

    guess, unravel = ravel_pytree((x_guess, u_guess, adj_guess))
    self.x_guess, self.u_guess, self.adj_guess = x_guess, u_guess, adj_guess

    x_bounds = system.bounds[:-1]
    u_bounds = system.bounds[-1:]
    bounds = jnp.vstack((x_bounds, u_bounds))
    self.x_bounds, self.u_bounds = x_bounds, u_bounds

    # Additional condition if terminal condition are present
    self.terminal_cdtion = False
    if self.system.x_T is not None:
      num_term_state = 0
      for idx, x_Ti in enumerate(self.system.x_T):
        if x_Ti is not None:
          self.terminal_cdtion = True
          self.term_cdtion_state = idx
          self.term_value = x_Ti
          num_term_state += 1
        if num_term_state &gt; 1:
          raise NotImplementedError(&#34;Multiple states with terminal condition not supported yet&#34;)

    super().__init__(hp, cfg, bounds, guess, unravel)

  def reinitiate(self, a):
    &#34;&#34;&#34;Helper function for `sequencesolver`
    &#34;&#34;&#34;
    state_shape = self.system.x_0.shape[0]
    control_shape = self.system.bounds.shape[0] - state_shape

    self.x_guess = jnp.vstack((self.system.x_0, jnp.zeros((self.N, state_shape))))
    self.u_guess = jnp.zeros((self.N + 1, control_shape))
    if self.system.adj_T is not None:
      adj_guess = jnp.vstack((jnp.zeros((self.N, state_shape)), self.system.adj_T))
    else:
      adj_guess = jnp.zeros((self.N + 1, state_shape))
    self.adj_guess = index_update(adj_guess, (-1, self.term_cdtion_state), a)

  def solve(self) -&gt; Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:
    &#34;&#34;&#34;Solve the continuous optimal problem with the Forward-Backward Sweep Method&#34;&#34;&#34;
    if self.terminal_cdtion:
      return self.sequencesolver()
    n = 0
    while n == 0 or self.stopping_criterion((self.x_guess, old_x), (self.u_guess, old_u), (self.adj_guess, old_adj)):
      old_u = self.u_guess.copy()
      old_x = self.x_guess.copy()
      old_adj = self.adj_guess.copy()

      self.x_guess = integrate_fbsm(self.system.dynamics, self.x_guess[0], self.u_guess, self.h, self.N,
                                    t=self.t_interval, discrete=self.system.discrete)[-1]
      self.adj_guess = integrate_fbsm(self.system.adj_ODE, self.adj_guess[-1], self.x_guess, -1 * self.h, self.N,
                                      self.u_guess, t=self.t_interval, discrete=self.system.discrete)[-1]

      u_estimate = self.system.optim_characterization(self.adj_guess, self.x_guess, self.t_interval)
      # Use basic convex approximation to update the guess on u
      self.u_guess = 0.5*(u_estimate + old_u)

      n = n + 1

    return self.x_guess, self.u_guess, self.adj_guess

  def sequencesolver(self) -&gt; Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:
    &#34;&#34;&#34;Implement the secant method for the special case where there is a terminal value on some state variables in
    addition to the initial values.
    &#34;&#34;&#34;
    self.terminal_cdtion = False
    count = 0

    # Adjust lambda to the initial guess
    a = self.system.guess_a
    self.reinitiate(a)
    x_a, _, _ = self.solve()
    Va = x_a[-1, self.term_cdtion_state] - self.term_value
    b = self.system.guess_b
    self.reinitiate(b)
    x_b, _, _ = self.solve()
    Vb = x_b[-1, self.term_cdtion_state] - self.term_value

    while jnp.abs(Va) &gt; 1e-10:
      if jnp.abs(Va) &gt; jnp.abs(Vb):
        a, b = b, a
        Va, Vb = Vb, Va

      d = Va*(b-a)/(Vb-Va)
      b = a
      Vb = Va
      a = a - d
      self.reinitiate(a)
      x_a, _, _ = self.solve()
      Va = x_a[-1, self.term_cdtion_state] - self.term_value
      count += 1

    return self.x_guess, self.u_guess, self.adj_guess</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="myriad.optimizers.get_optimizer"><code class="name flex">
<span>def <span class="ident">get_optimizer</span></span>(<span>hp, cfg, system)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to fetch the desired optimizer for system resolution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_optimizer(hp: HParams, cfg: Config, system: Union[FiniteHorizonControlSystem, IndirectFHCS]
                  ) -&gt; Union[TrajectoryOptimizer, IndirectMethodOptimizer]:
  &#34;&#34;&#34; Helper function to fetch the desired optimizer for system resolution&#34;&#34;&#34;
  if hp.optimizer == OptimizerType.COLLOCATION:
    if hp.order == IntegrationOrder.CONSTANT:
      print(&#34;CONSTANT collocation not yet implemented; using LINEAR collocation for now&#34;)
      optimizer = TrapezoidalCollocationOptimizer(hp, cfg, system)
    elif hp.order == IntegrationOrder.LINEAR:
      optimizer = TrapezoidalCollocationOptimizer(hp, cfg, system)
    else:  # Quadratic
      optimizer = HermiteSimpsonCollocationOptimizer(hp, cfg, system)
  elif hp.optimizer == OptimizerType.SHOOTING:
    optimizer = MultipleShootingOptimizer(hp, cfg, system)
  elif hp.optimizer == OptimizerType.FBSM:
    optimizer = FBSM(hp, cfg, system)
  else:
    raise KeyError
  return optimizer</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="myriad.optimizers.TrajectoryOptimizer"><code class="flex name class">
<span>class <span class="ident">TrajectoryOptimizer</span></span>
<span>(</span><span>_type, hp, cfg, objective, constraints, bounds, guess, unravel, require_adj=False)</span>
</code></dt>
<dd>
<div class="desc"><p>TrajectoryOptimizer(_type: myriad.config.OptimizerType, hp: myriad.config.HParams, cfg: myriad.config.Config, objective: Callable[[jax._src.numpy.lax_numpy.ndarray], float], constraints: Callable[[jax._src.numpy.lax_numpy.ndarray], jax._src.numpy.lax_numpy.ndarray], bounds: jax._src.numpy.lax_numpy.ndarray, guess: jax._src.numpy.lax_numpy.ndarray, unravel: Callable[[jax._src.numpy.lax_numpy.ndarray], Tuple], require_adj: bool = False)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrajectoryOptimizer(object):
  _type: OptimizerType
  hp: HParams
  cfg: Config
  objective: Callable[[jnp.ndarray], float]
  constraints: Callable[[jnp.ndarray], jnp.ndarray]
  bounds: jnp.ndarray
  guess: jnp.ndarray
  unravel: Callable[[jnp.ndarray], Tuple]
  require_adj: bool = False

  def __post_init__(self):
    # if self.cfg.verbose:
    #   print(f&#34;x_guess.shape = {self.x_guess.shape}&#34;)
    #   print(f&#34;u_guess.shape = {self.u_guess.shape}&#34;)
    #   print(f&#34;guess.shape = {self.guess.shape}&#34;)
    #   print(f&#34;x_bounds.shape = {self.x_bounds.shape}&#34;)
    #   print(f&#34;u_bounds.shape = {self.u_bounds.shape}&#34;)
    #   print(f&#34;bounds.shape = {self.bounds.shape}&#34;)

    if self.hp.system == SystemType.INVASIVEPLANT:
      raise NotImplementedError(&#34;Discrete systems are not compatible with Trajectory optimizers&#34;)

  def solve(self, extra_options=None) -&gt; Tuple[jnp.ndarray, jnp.ndarray]:
    _t1 = time.time()
    options = {&#34;maxiter&#34;: self.hp.max_iter}
    # Merge the two dictionaries, keeping the entry from &#39;extra_options&#39; in the case of a key collision
    if extra_options is not None and self.hp.nlpsolver == NLPSolverType.EXTRAGRADIENT:
      options = {**options, **extra_options}
      print(&#34;loaded extra options&#34;)
    opt_inputs = {
      &#39;fun&#39;: jit(self.objective) if self.cfg.jit else self.objective,
      &#39;x0&#39;: self.guess,
      &#39;constraints&#39;: ({
        &#39;type&#39;: &#39;eq&#39;,
        &#39;fun&#39;: jit(self.constraints) if self.cfg.jit else self.constraints,
        &#39;jac&#39;: jit(jacrev(self.constraints)) if self.cfg.jit else jacrev(self.constraints),
      }),
      &#39;bounds&#39;: self.bounds,
      &#39;jac&#39;: jit(grad(self.objective)) if self.cfg.jit else grad(self.objective),
      &#39;options&#39;: options
    }
    if self.hp.nlpsolver == NLPSolverType.EXTRAGRADIENT:
      del opt_inputs[&#39;jac&#39;]
      solution = extra_gradient(**opt_inputs)
    elif self.hp.nlpsolver == NLPSolverType.SLSQP:
      opt_inputs[&#39;method&#39;] = &#39;SLSQP&#39;
      solution = minimize(**opt_inputs)
    elif self.hp.nlpsolver == NLPSolverType.TRUST:
      opt_inputs[&#39;method&#39;] = &#39;trust-constr&#39;
      solution = minimize(**opt_inputs)
    elif self.hp.nlpsolver == NLPSolverType.IPOPT:
      solution = minimize_ipopt(**opt_inputs)
    else:
      print(&#34;Unknown NLP solver. Please choose among&#34;, list(NLPSolverType.__members__.keys()))
      raise ValueError
    _t2 = time.time()
    if self.cfg.verbose:
      print(&#39;Solver exited with success:&#39;, solution.success)
      print(f&#39;Completed in {_t2 - _t1} seconds.&#39;)

    if self.hp.order == IntegrationOrder.QUADRATIC and self._type == OptimizerType.COLLOCATION:
      x, x_mid, u, u_mid = self.unravel(solution.x)
    else:
      x, u = self.unravel(solution.x)

    return x, u</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="myriad.optimizers.HermiteSimpsonCollocationOptimizer" href="#myriad.optimizers.HermiteSimpsonCollocationOptimizer">HermiteSimpsonCollocationOptimizer</a></li>
<li><a title="myriad.optimizers.MultipleShootingOptimizer" href="#myriad.optimizers.MultipleShootingOptimizer">MultipleShootingOptimizer</a></li>
<li><a title="myriad.optimizers.TrapezoidalCollocationOptimizer" href="#myriad.optimizers.TrapezoidalCollocationOptimizer">TrapezoidalCollocationOptimizer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="myriad.optimizers.TrajectoryOptimizer.hp"><code class="name">var <span class="ident">hp</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.TrajectoryOptimizer.cfg"><code class="name">var <span class="ident">cfg</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.TrajectoryOptimizer.objective"><code class="name">var <span class="ident">objective</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.TrajectoryOptimizer.constraints"><code class="name">var <span class="ident">constraints</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.TrajectoryOptimizer.bounds"><code class="name">var <span class="ident">bounds</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.TrajectoryOptimizer.guess"><code class="name">var <span class="ident">guess</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.TrajectoryOptimizer.unravel"><code class="name">var <span class="ident">unravel</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="myriad.optimizers.TrajectoryOptimizer.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self, extra_options=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve(self, extra_options=None) -&gt; Tuple[jnp.ndarray, jnp.ndarray]:
  _t1 = time.time()
  options = {&#34;maxiter&#34;: self.hp.max_iter}
  # Merge the two dictionaries, keeping the entry from &#39;extra_options&#39; in the case of a key collision
  if extra_options is not None and self.hp.nlpsolver == NLPSolverType.EXTRAGRADIENT:
    options = {**options, **extra_options}
    print(&#34;loaded extra options&#34;)
  opt_inputs = {
    &#39;fun&#39;: jit(self.objective) if self.cfg.jit else self.objective,
    &#39;x0&#39;: self.guess,
    &#39;constraints&#39;: ({
      &#39;type&#39;: &#39;eq&#39;,
      &#39;fun&#39;: jit(self.constraints) if self.cfg.jit else self.constraints,
      &#39;jac&#39;: jit(jacrev(self.constraints)) if self.cfg.jit else jacrev(self.constraints),
    }),
    &#39;bounds&#39;: self.bounds,
    &#39;jac&#39;: jit(grad(self.objective)) if self.cfg.jit else grad(self.objective),
    &#39;options&#39;: options
  }
  if self.hp.nlpsolver == NLPSolverType.EXTRAGRADIENT:
    del opt_inputs[&#39;jac&#39;]
    solution = extra_gradient(**opt_inputs)
  elif self.hp.nlpsolver == NLPSolverType.SLSQP:
    opt_inputs[&#39;method&#39;] = &#39;SLSQP&#39;
    solution = minimize(**opt_inputs)
  elif self.hp.nlpsolver == NLPSolverType.TRUST:
    opt_inputs[&#39;method&#39;] = &#39;trust-constr&#39;
    solution = minimize(**opt_inputs)
  elif self.hp.nlpsolver == NLPSolverType.IPOPT:
    solution = minimize_ipopt(**opt_inputs)
  else:
    print(&#34;Unknown NLP solver. Please choose among&#34;, list(NLPSolverType.__members__.keys()))
    raise ValueError
  _t2 = time.time()
  if self.cfg.verbose:
    print(&#39;Solver exited with success:&#39;, solution.success)
    print(f&#39;Completed in {_t2 - _t1} seconds.&#39;)

  if self.hp.order == IntegrationOrder.QUADRATIC and self._type == OptimizerType.COLLOCATION:
    x, x_mid, u, u_mid = self.unravel(solution.x)
  else:
    x, u = self.unravel(solution.x)

  return x, u</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="myriad.optimizers.IndirectMethodOptimizer"><code class="flex name class">
<span>class <span class="ident">IndirectMethodOptimizer</span></span>
<span>(</span><span>hp, cfg, bounds, guess, unravel, require_adj=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for implementing indirect method optimizers, i.e. optimizers that relies on the Pontryagin's maximum principle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IndirectMethodOptimizer(object):
  &#34;&#34;&#34;
  Base class for implementing indirect method optimizers, i.e. optimizers that relies on the Pontryagin&#39;s maximum principle
  &#34;&#34;&#34;
  hp: HParams
  &#34;&#34;&#34;The collection of hyperparameters for the experiment&#34;&#34;&#34;
  cfg: Config
  &#34;&#34;&#34;Configuration options that should not impact results&#34;&#34;&#34;
  bounds: jnp.ndarray
  &#34;&#34;&#34;Bounds (lower, upper) over the state variables, followed by the bounds over the controls&#34;&#34;&#34;
  guess: jnp.ndarray    # Initial guess on x_t, u_t and adj_t
  &#34;&#34;&#34;Initial guess for the state, control and adjoint variables&#34;&#34;&#34;
  unravel: Callable[[jnp.ndarray], Tuple[jnp.ndarray, jnp.ndarray]]
  &#34;&#34;&#34;Callable to unravel the pytree&#34;&#34;&#34;
  require_adj: bool = True
  &#34;&#34;&#34;(bool, optional) -- &#34;&#34;&#34;

  def solve(self) -&gt; Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:
    &#34;&#34;&#34;Solve method&#34;&#34;&#34;
    raise NotImplementedError

  def stopping_criterion(self, x_iter: Tuple[jnp.ndarray, jnp.ndarray], u_iter: Tuple[jnp.ndarray, jnp.ndarray],
                         adj_iter: Tuple[jnp.ndarray, jnp.ndarray], delta: float = 0.001) -&gt; bool:
    &#34;&#34;&#34;
    Criterion for stopping the optimization iterations.
    &#34;&#34;&#34;
    x, old_x = x_iter
    u, old_u = u_iter
    adj, old_adj = adj_iter

    stop_x = jnp.abs(x).sum(axis=0) * delta - jnp.abs(x - old_x).sum(axis=0)
    stop_u = jnp.abs(u).sum(axis=0)*delta - jnp.abs(u-old_u).sum(axis=0)
    stop_adj = jnp.abs(adj).sum(axis=0) * delta - jnp.abs(adj - old_adj).sum(axis=0)

    return jnp.min(jnp.hstack((stop_u, stop_x, stop_adj))) &lt; 0</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="myriad.optimizers.FBSM" href="#myriad.optimizers.FBSM">FBSM</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="myriad.optimizers.IndirectMethodOptimizer.hp"><code class="name">var <span class="ident">hp</span></code></dt>
<dd>
<div class="desc"><p>The collection of hyperparameters for the experiment</p></div>
</dd>
<dt id="myriad.optimizers.IndirectMethodOptimizer.cfg"><code class="name">var <span class="ident">cfg</span></code></dt>
<dd>
<div class="desc"><p>Configuration options that should not impact results</p></div>
</dd>
<dt id="myriad.optimizers.IndirectMethodOptimizer.bounds"><code class="name">var <span class="ident">bounds</span></code></dt>
<dd>
<div class="desc"><p>Bounds (lower, upper) over the state variables, followed by the bounds over the controls</p></div>
</dd>
<dt id="myriad.optimizers.IndirectMethodOptimizer.guess"><code class="name">var <span class="ident">guess</span></code></dt>
<dd>
<div class="desc"><p>Initial guess for the state, control and adjoint variables</p></div>
</dd>
<dt id="myriad.optimizers.IndirectMethodOptimizer.unravel"><code class="name">var <span class="ident">unravel</span></code></dt>
<dd>
<div class="desc"><p>Callable to unravel the pytree</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="myriad.optimizers.IndirectMethodOptimizer.stopping_criterion"><code class="name flex">
<span>def <span class="ident">stopping_criterion</span></span>(<span>self, x_iter, u_iter, adj_iter, delta=0.001)</span>
</code></dt>
<dd>
<div class="desc"><p>Criterion for stopping the optimization iterations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stopping_criterion(self, x_iter: Tuple[jnp.ndarray, jnp.ndarray], u_iter: Tuple[jnp.ndarray, jnp.ndarray],
                       adj_iter: Tuple[jnp.ndarray, jnp.ndarray], delta: float = 0.001) -&gt; bool:
  &#34;&#34;&#34;
  Criterion for stopping the optimization iterations.
  &#34;&#34;&#34;
  x, old_x = x_iter
  u, old_u = u_iter
  adj, old_adj = adj_iter

  stop_x = jnp.abs(x).sum(axis=0) * delta - jnp.abs(x - old_x).sum(axis=0)
  stop_u = jnp.abs(u).sum(axis=0)*delta - jnp.abs(u-old_u).sum(axis=0)
  stop_adj = jnp.abs(adj).sum(axis=0) * delta - jnp.abs(adj - old_adj).sum(axis=0)

  return jnp.min(jnp.hstack((stop_u, stop_x, stop_adj))) &lt; 0</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="myriad.optimizers.TrapezoidalCollocationOptimizer"><code class="flex name class">
<span>class <span class="ident">TrapezoidalCollocationOptimizer</span></span>
<span>(</span><span>hp, cfg, system)</span>
</code></dt>
<dd>
<div class="desc"><p>TrajectoryOptimizer(_type: myriad.config.OptimizerType, hp: myriad.config.HParams, cfg: myriad.config.Config, objective: Callable[[jax._src.numpy.lax_numpy.ndarray], float], constraints: Callable[[jax._src.numpy.lax_numpy.ndarray], jax._src.numpy.lax_numpy.ndarray], bounds: jax._src.numpy.lax_numpy.ndarray, guess: jax._src.numpy.lax_numpy.ndarray, unravel: Callable[[jax._src.numpy.lax_numpy.ndarray], Tuple], require_adj: bool = False)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrapezoidalCollocationOptimizer(TrajectoryOptimizer):
  def __init__(self, hp: HParams, cfg: Config, system: FiniteHorizonControlSystem):
    num_intervals = hp.intervals  # Segments
    h = system.T / num_intervals  # Segment length
    state_shape = system.x_0.shape[0]
    control_shape = system.bounds.shape[0] - state_shape

    u_guess = jnp.zeros((num_intervals+1, control_shape))
    u_mean = system.bounds[-1 * control_shape:].mean()

    if (not jnp.isnan(jnp.sum(u_mean))) and (not jnp.isinf(u_mean).any()):  # handle bounds with infinite values
      u_guess += u_mean

    if system.x_T is not None:
      # We need to handle the cases where a terminal bound is specified only for some state variables, not all
      row_guesses = []
      for i in range(0, len(system.x_T)):
        if system.x_T[i] is not None:
          row_guess = jnp.linspace(system.x_0[i], system.x_T[i], num=num_intervals+1).reshape(-1, 1)
        else:
          _, row_guess = integrate(system.dynamics, system.x_0, u_guess, h, num_intervals, None, hp.order)
          row_guess = row_guess[:, i].reshape(-1, 1)
        row_guesses.append(row_guess)
      x_guess = jnp.hstack(row_guesses)
    else:  # no final state requirement
      _, x_guess = integrate(system.dynamics, system.x_0, u_guess, h, num_intervals, None, hp.order)
    guess, unravel_decision_variables = ravel_pytree((x_guess, u_guess))
    self.x_guess, self.u_guess = x_guess, u_guess

    def trapezoid_cost(x_t1: jnp.ndarray, x_t2: jnp.ndarray, u_t1: float, u_t2: float, t1: float, t2: float) -&gt; float:
      return (h/2) * (system.cost(x_t1, u_t1, t1) + system.cost(x_t2, u_t2, t2))

    def objective(variables: jnp.ndarray) -&gt; float:
      x, u = unravel_decision_variables(variables)
      t = jnp.linspace(0, system.T, num=num_intervals+1)  # Support cost function with dependency on t
      cost = jnp.sum(vmap(trapezoid_cost)(x[:-1], x[1:], u[:-1], u[1:], t[:-1], t[1:]))
      if system.terminal_cost:
        cost += jnp.sum(system.terminal_cost_fn(x[-1], u[-1]))
      return cost

    def trapezoid_defect(x_t1: jnp.ndarray, x_t2: jnp.ndarray, u_t1: float, u_t2: float) -&gt; jnp.ndarray:
      left = (h/2) * (system.dynamics(x_t1, u_t1) + system.dynamics(x_t2, u_t2))
      right = x_t2 - x_t1
      return left - right

    def constraints(variables: jnp.ndarray) -&gt; jnp.ndarray:
      x, u = unravel_decision_variables(variables)
      return jnp.ravel(vmap(trapezoid_defect)(x[:-1], x[1:], u[:-1], u[1:]))

    ############################
    # State and Control Bounds #
    ############################
    
    x_bounds = np.empty((num_intervals+1, system.bounds.shape[0]-control_shape, 2))
    x_bounds[:, :, :] = system.bounds[:-control_shape]
    x_bounds[0, :, :] = np.expand_dims(system.x_0, 1)
    if system.x_T is not None:
      x_bounds[-control_shape, :, :] = np.expand_dims(system.x_T, 1)
    x_bounds = x_bounds.reshape((-1, 2))
    u_bounds = np.empty(((num_intervals+1)*control_shape, 2))
    for i in range(control_shape, 0, -1):
      u_bounds[(control_shape-i)*(num_intervals+1):(control_shape-i+1)*(num_intervals+1)] = system.bounds[-i]
    bounds = jnp.vstack((x_bounds, u_bounds))
    self.x_bounds, self.u_bounds = x_bounds, u_bounds

    super().__init__(OptimizerType.COLLOCATION, hp, cfg, objective, constraints, bounds, guess, unravel_decision_variables)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="myriad.optimizers.TrajectoryOptimizer" href="#myriad.optimizers.TrajectoryOptimizer">TrajectoryOptimizer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="myriad.optimizers.TrapezoidalCollocationOptimizer.hp"><code class="name">var <span class="ident">hp</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.TrapezoidalCollocationOptimizer.cfg"><code class="name">var <span class="ident">cfg</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.TrapezoidalCollocationOptimizer.objective"><code class="name">var <span class="ident">objective</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.TrapezoidalCollocationOptimizer.constraints"><code class="name">var <span class="ident">constraints</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.TrapezoidalCollocationOptimizer.bounds"><code class="name">var <span class="ident">bounds</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.TrapezoidalCollocationOptimizer.guess"><code class="name">var <span class="ident">guess</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.TrapezoidalCollocationOptimizer.unravel"><code class="name">var <span class="ident">unravel</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="myriad.optimizers.HermiteSimpsonCollocationOptimizer"><code class="flex name class">
<span>class <span class="ident">HermiteSimpsonCollocationOptimizer</span></span>
<span>(</span><span>hp, cfg, system)</span>
</code></dt>
<dd>
<div class="desc"><p>TrajectoryOptimizer(_type: myriad.config.OptimizerType, hp: myriad.config.HParams, cfg: myriad.config.Config, objective: Callable[[jax._src.numpy.lax_numpy.ndarray], float], constraints: Callable[[jax._src.numpy.lax_numpy.ndarray], jax._src.numpy.lax_numpy.ndarray], bounds: jax._src.numpy.lax_numpy.ndarray, guess: jax._src.numpy.lax_numpy.ndarray, unravel: Callable[[jax._src.numpy.lax_numpy.ndarray], Tuple], require_adj: bool = False)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HermiteSimpsonCollocationOptimizer(TrajectoryOptimizer):

  def __init__(self, hp: HParams, cfg: Config, system: FiniteHorizonControlSystem):
    num_intervals = hp.intervals
    interval_duration = system.T / hp.intervals

    u_guess, mid_u_guess = jnp.ones(num_intervals + 1) * 0.1, jnp.zeros(num_intervals) * 0.1

    # Initial guess for state and controls
    # O . . . O (guess dots)
    if system.x_T is not None:
      full_x_guess = jnp.linspace(system.x_0, system.x_T, num=hp.intervals + 1)

      # make the mid states linear too (interpolate between collocation points)
      mid_x_guess = np.copy((full_x_guess[:-1] + full_x_guess[1:])/2)
      # Now remove the end points from the state guesses
      x_guess = jnp.linspace(system.x_0, system.x_T, num=hp.intervals + 1)[1:-1]
    # O . . . . (guess dots)
    else:
      # _, x_guess = integrate(system.dynamics, system.x_0, u_guess, interval_duration, num_intervals)[1:] # should be right
      x_guess = jnp.ones(shape=(num_intervals, len(system.x_0))) * 0.25
      mid_x_guess = jnp.ones(shape=(num_intervals, len(system.x_0))) * 0.25

    initial_variables = (x_guess, mid_x_guess, u_guess, mid_u_guess)

    guess, unravel_decision_variables = ravel_pytree(initial_variables)
    self.x_guess, self.u_guess = x_guess, u_guess

    ############################
    # State and Control Bounds #
    ############################

    u_bounds = np.empty((num_intervals + 1, 2))
    u_bounds[:] = system.bounds[-1:]

    mid_u_bounds = np.empty((num_intervals, 2))
    mid_u_bounds[:] = system.bounds[-1:]

    single_x_bounds = system.bounds[:-1].flatten()

    if system.x_T is not None:
      x_bounds = jnp.tile(single_x_bounds, reps=(num_intervals - 1, 1))
      mid_x_bounds = jnp.tile(single_x_bounds, reps=(num_intervals, 1))
    else:
      x_bounds = jnp.tile(single_x_bounds, reps=(num_intervals, 1))
      mid_x_bounds = jnp.tile(single_x_bounds, reps=(num_intervals, 1))

    x_bounds = x_bounds.reshape(-1, 2)
    mid_x_bounds = mid_x_bounds.reshape(-1, 2)

    bounds = jnp.vstack((x_bounds, mid_x_bounds, u_bounds, mid_u_bounds))
    self.x_bounds, self.u_bounds = x_bounds, u_bounds

    # Convenience function
    def get_start_and_next_states_and_controls(variables: jnp.ndarray) -&gt; Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray,
                                                                                jnp.ndarray, jnp.ndarray, jnp.ndarray]:
      xs, mid_xs, us, mid_us = unravel_decision_variables(variables)

      if system.x_T is not None:
        starting_states = jnp.concatenate((system.x_0[jnp.newaxis], xs))
        desired_next_states = jnp.concatenate((xs, system.x_T[jnp.newaxis]))
      else:  # last &#34;decision state&#34; is actually final state in this case
        starting_states = jnp.concatenate((system.x_0[jnp.newaxis], xs[:-1]))
        desired_next_states = xs

      return starting_states, mid_xs, desired_next_states, \
             us[:-1],         mid_us, us[1:]

    # Hermite-Simpson collocation constraints (calculates midpoint constraints on-the-fly)
    def hs_defect(state, mid_state, next_state, control, mid_control, next_control):
      rhs = next_state - state
      lhs = (interval_duration / 6) \
          * ( system.dynamics(state, control)
              + 4 * system.dynamics(mid_state, mid_control)
              + system.dynamics(next_state, next_control) )
      return rhs - lhs

    # Hermite-Simpson interpolation constraints
    def hs_interpolation(state, mid_state, next_state, control, mid_control, next_control):
      return (mid_state
              - (1/2) * (state + next_state)
              - (interval_duration/8) * (system.dynamics(state, control) - system.dynamics(next_state, next_control)))

    # This is the &#34;J&#34; from the tutorial (6.5)
    def hs_cost(state, mid_state, next_state, control, mid_control, next_control):
      return (interval_duration/6) \
              * ( system.cost(state, control)
                  + 4 * system.cost(mid_state, mid_control)
                  + system.cost(next_state, next_control) )

    #######################
    # Cost and Constraint #
    #######################
    def objective(variables):
      unraveled_vars = get_start_and_next_states_and_controls(variables)
      return jnp.sum(vmap(hs_cost)(*unraveled_vars))

    def hs_equality_constraints(variables):
      unraveled_vars = get_start_and_next_states_and_controls(variables)
      return jnp.ravel(vmap(hs_defect)(*unraveled_vars))

    def hs_interpolation_constraints(variables):
      unraveled_vars = get_start_and_next_states_and_controls(variables)
      return jnp.ravel(vmap(hs_interpolation)(*unraveled_vars))

    def constraints(variables):
      equality_defects = hs_equality_constraints(variables)
      interpolation_defects = hs_interpolation_constraints(variables)
      return jnp.hstack((equality_defects, interpolation_defects))

    super().__init__(OptimizerType.COLLOCATION, hp, cfg, objective, constraints, bounds, guess, unravel_decision_variables)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="myriad.optimizers.TrajectoryOptimizer" href="#myriad.optimizers.TrajectoryOptimizer">TrajectoryOptimizer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="myriad.optimizers.HermiteSimpsonCollocationOptimizer.hp"><code class="name">var <span class="ident">hp</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.HermiteSimpsonCollocationOptimizer.cfg"><code class="name">var <span class="ident">cfg</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.HermiteSimpsonCollocationOptimizer.objective"><code class="name">var <span class="ident">objective</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.HermiteSimpsonCollocationOptimizer.constraints"><code class="name">var <span class="ident">constraints</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.HermiteSimpsonCollocationOptimizer.bounds"><code class="name">var <span class="ident">bounds</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.HermiteSimpsonCollocationOptimizer.guess"><code class="name">var <span class="ident">guess</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.HermiteSimpsonCollocationOptimizer.unravel"><code class="name">var <span class="ident">unravel</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="myriad.optimizers.MultipleShootingOptimizer"><code class="flex name class">
<span>class <span class="ident">MultipleShootingOptimizer</span></span>
<span>(</span><span>hp, cfg, system)</span>
</code></dt>
<dd>
<div class="desc"><p>TrajectoryOptimizer(_type: myriad.config.OptimizerType, hp: myriad.config.HParams, cfg: myriad.config.Config, objective: Callable[[jax._src.numpy.lax_numpy.ndarray], float], constraints: Callable[[jax._src.numpy.lax_numpy.ndarray], jax._src.numpy.lax_numpy.ndarray], bounds: jax._src.numpy.lax_numpy.ndarray, guess: jax._src.numpy.lax_numpy.ndarray, unravel: Callable[[jax._src.numpy.lax_numpy.ndarray], Tuple], require_adj: bool = False)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultipleShootingOptimizer(TrajectoryOptimizer):
  def __init__(self, hp: HParams, cfg: Config, system: FiniteHorizonControlSystem):
    num_steps = hp.intervals * hp.controls_per_interval
    step_size = system.T / num_steps
    interval_size = system.T / hp.intervals
    state_shape = system.x_0.shape[0]
    control_shape = system.bounds.shape[0] - state_shape
    midpoints_const = 2 if hp.order == IntegrationOrder.QUADRATIC else 1

    #################
    # Initial Guess #
    #################

    # Controls
    controls_guess = jnp.zeros((midpoints_const*num_steps + 1, control_shape))
    controls_mean = system.bounds[-1 * control_shape:].mean()
    if (not jnp.isnan(jnp.sum(controls_mean))) and (not jnp.isinf(controls_mean).any()):  # handle bounds with infinite values
      controls_guess += controls_mean

    # States
    if system.x_T is not None:
      row_guesses = []
      # For the state variables which have a required end state, interpolate between start and end;
      # otherwise, use rk4 with initial controls as a first guess at intermediate and end state values
      for i in range(0, len(system.x_T)):
        if system.x_T[i] is not None:
          row_guess = jnp.linspace(system.x_0[i], system.x_T[i], num=hp.intervals+1).reshape(-1, 1)
        else:
          _, row_guess = integrate(system.dynamics, system.x_0, controls_guess[::midpoints_const*hp.controls_per_interval], interval_size, hp.intervals, None, hp.order)
          row_guess = row_guess[:, i].reshape(-1, 1)
        row_guesses.append(row_guess)
      x_guess = jnp.hstack(row_guesses)
    else:
      _, x_guess = integrate(system.dynamics, system.x_0, controls_guess[::midpoints_const*hp.controls_per_interval], interval_size, hp.intervals, None, hp.order)
    guess, unravel = ravel_pytree((x_guess, controls_guess))
    assert len(x_guess) == hp.intervals + 1  # we have one state decision var for each node, including start and end
    self.x_guess, self.u_guess = x_guess, controls_guess

    # Augment the dynamics so we can integrate cost the same way we do state
    def augmented_dynamics(x_and_c: jnp.ndarray, u: float, t: jnp.ndarray) -&gt; jnp.ndarray:
      x, c = x_and_c[:-1], x_and_c[-1]
      return jnp.append(system.dynamics(x, u), system.cost(x, u, t))

    # Go from having controls like (num_controls + 1, control_shape) (left)
    #                      to like (hp.intervals, num_controls_per_interval + 1, control_shape) (right)
    # [ 1. ,  1.1]                [ 1. ,  1.1]
    # [ 2. ,  2.1]                [ 2. ,  2.1]
    # [ 3. ,  3.1]                [ 3. ,  3.1]
    # [ 4. ,  4.1]                [ 4. ,  4.1]
    # [ 5. ,  5.1]
    # [ 6. ,  6.1]                [ 4. ,  4.1]
    # [ 7. ,  7.1]                [ 5. ,  5.1]
    # [ 8. ,  8.1]                [ 6. ,  6.1]
    # [ 9. ,  9.1]                [ 7. ,  7.1]
    # [10. , 10.1]
    #                             [ 7. ,  7.1]
    #                             [ 8. ,  8.1]
    #                             [ 9. ,  9.1]
    #                             [10. , 10.1]
    def reorganize_controls(us):  # This still works, even for higher-order control shape
      new_controls = jnp.hstack([us[:-1].reshape(hp.intervals, midpoints_const*hp.controls_per_interval, control_shape),
                                us[::midpoints_const*hp.controls_per_interval][1:][:, jnp.newaxis]])
      # Needed for single shooting
      if len(new_controls.shape) == 3 and new_controls.shape[2] == 1:
        new_controls = new_controls.squeeze(axis=2)
      return new_controls

    # Same idea as above function, but for the times
    def reorganize_times(ts):
      new_times = jnp.hstack([ts[:-1].reshape(hp.intervals, hp.controls_per_interval),
                             ts[::hp.controls_per_interval][1:][:, jnp.newaxis]])
      return new_times

    def objective(variables: jnp.ndarray) -&gt; float:
      # print(&#34;dynamics are&#34;, system.dynamics)
      # The commented code runs faster, but only does a linear interpolation for cost.
      # Better to have the interpolation match the integration scheme,
      # and just use Euler / Heun if we need shooting to be faster

      # xs, us = unravel(variables)
      # t = jnp.linspace(0, system.T, num=N_x+1)[:-1]  # Support cost function with dependency on t
      # t = jnp.repeat(t, hp.controls_per_interval)
      # _, x = integrate(system.dynamics, system.x_0, u, h_u, N_u)
      # x = x[:-1]
      # if system.terminal_cost:
      #   return jnp.sum(system.terminal_cost_fn(x[-1], u[-1])) + h_u * jnp.sum(vmap(system.cost)(x, u, t))
      # else:
      #   return h_u * jnp.sum(vmap(system.cost)(x, u, t))
      # ---
      xs, us = unravel(variables)
      reshaped_controls = reorganize_controls(us)

      t = jnp.linspace(0., system.T, num=num_steps + 1)
      t = reorganize_times(t)

      starting_xs_and_costs = jnp.hstack([xs[:-1], jnp.zeros(len(xs[:-1])).reshape(-1, 1)])

      # Integrate cost in parallel
      states_and_costs, _ = integrate_in_parallel(
        augmented_dynamics, starting_xs_and_costs, reshaped_controls,
        step_size, hp.controls_per_interval, t, hp.order)

      costs = jnp.sum(states_and_costs[:,-1])
      if system.terminal_cost:
        last_augmented_state = states_and_costs[-1]
        costs += system.terminal_cost_fn(last_augmented_state[:-1], us[-1])

      return costs
    
    def constraints(variables: jnp.ndarray) -&gt; jnp.ndarray:
      xs, us = unravel(variables)
      px, _ = integrate_in_parallel(system.dynamics, xs[:-1], reorganize_controls(us), step_size,
                                    hp.controls_per_interval, None, hp.order)
      return jnp.ravel(px - xs[1:])

    ############################
    # State and Control Bounds #
    ############################

    # State decision variables at every node
    x_bounds = np.zeros((hp.intervals + 1, system.bounds.shape[0] - control_shape, 2))
    x_bounds[:, :, :] = system.bounds[:-control_shape]

    # Starting state
    x_bounds[0, :, :] = jnp.expand_dims(system.x_0, 1)

    # Ending state
    if system.x_T is not None:
      for i in range(len(system.x_T)):
        if system.x_T[i] is not None:
          x_bounds[-1, i, :] = system.x_T[i]

    # Reshape for ipopt&#39;s minimize
    x_bounds = x_bounds.reshape((-1, 2))

    # Control decision variables at every node, and if QUADRATIC order, also at midpoints
    u_bounds = np.empty(((midpoints_const*num_steps + 1) * control_shape, 2)) # Include midpoints too
    for i in range(control_shape, 0, -1):
      u_bounds[(control_shape - i) * (midpoints_const*num_steps + 1):(control_shape - i + 1) * (midpoints_const*num_steps + 1)] = system.bounds[-i]

    # print(&#34;u bounds&#34;, u_bounds)
    # Stack all bounds together for the NLP solver
    bounds = jnp.vstack((x_bounds, u_bounds))
    self.x_bounds, self.u_bounds = x_bounds, u_bounds

    super().__init__(OptimizerType.SHOOTING, hp, cfg, objective, constraints, bounds, guess, unravel)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="myriad.optimizers.TrajectoryOptimizer" href="#myriad.optimizers.TrajectoryOptimizer">TrajectoryOptimizer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="myriad.optimizers.MultipleShootingOptimizer.hp"><code class="name">var <span class="ident">hp</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.MultipleShootingOptimizer.cfg"><code class="name">var <span class="ident">cfg</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.MultipleShootingOptimizer.objective"><code class="name">var <span class="ident">objective</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.MultipleShootingOptimizer.constraints"><code class="name">var <span class="ident">constraints</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.MultipleShootingOptimizer.bounds"><code class="name">var <span class="ident">bounds</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.MultipleShootingOptimizer.guess"><code class="name">var <span class="ident">guess</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="myriad.optimizers.MultipleShootingOptimizer.unravel"><code class="name">var <span class="ident">unravel</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="myriad.optimizers.FBSM"><code class="flex name class">
<span>class <span class="ident">FBSM</span></span>
<span>(</span><span>hp, cfg, system)</span>
</code></dt>
<dd>
<div class="desc"><p>The Forward-Backward Sweep Method, as described in Optimal Control Applied to Biological Models, Lenhart &amp; Workman</p>
<p>An iterative solver that, given an initial guess over the controls, will do a forward pass to retrieve the state
variables trajectory followed by a backward pass to retrieve the adjoint variables trajectory. The optimality
characterization is then used to update the control values.</p>
<p>The process is repeated until convergence over the controls.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FBSM(IndirectMethodOptimizer):  # Forward-Backward Sweep Method
  &#34;&#34;&#34;
  The Forward-Backward Sweep Method, as described in Optimal Control Applied to Biological Models, Lenhart &amp; Workman

  An iterative solver that, given an initial guess over the controls, will do a forward pass to retrieve the state
  variables trajectory followed by a backward pass to retrieve the adjoint variables trajectory. The optimality
  characterization is then used to update the control values.

  The process is repeated until convergence over the controls.
  &#34;&#34;&#34;
  def __init__(self, hp: HParams, cfg: Config, system: IndirectFHCS):
    self.system = system
    self.N = hp.fbsm_intervals
    self.h = system.T / self.N
    if system.discrete:
      self.N = int(system.T)
      self.h = 1
    state_shape = system.x_0.shape[0]
    control_shape = system.bounds.shape[0] - state_shape

    x_guess = jnp.vstack((system.x_0, jnp.zeros((self.N, state_shape))))
    if system.discrete:
      u_guess = jnp.zeros((self.N, control_shape))
    else:
      u_guess = jnp.zeros((self.N+1, control_shape))
    if system.adj_T is not None:
      adj_guess = jnp.vstack((jnp.zeros((self.N, state_shape)), system.adj_T))
    else:
      adj_guess = jnp.zeros((self.N+1, state_shape))
    self.t_interval = jnp.linspace(0, system.T, num=self.N+1).reshape(-1, 1)

    guess, unravel = ravel_pytree((x_guess, u_guess, adj_guess))
    self.x_guess, self.u_guess, self.adj_guess = x_guess, u_guess, adj_guess

    x_bounds = system.bounds[:-1]
    u_bounds = system.bounds[-1:]
    bounds = jnp.vstack((x_bounds, u_bounds))
    self.x_bounds, self.u_bounds = x_bounds, u_bounds

    # Additional condition if terminal condition are present
    self.terminal_cdtion = False
    if self.system.x_T is not None:
      num_term_state = 0
      for idx, x_Ti in enumerate(self.system.x_T):
        if x_Ti is not None:
          self.terminal_cdtion = True
          self.term_cdtion_state = idx
          self.term_value = x_Ti
          num_term_state += 1
        if num_term_state &gt; 1:
          raise NotImplementedError(&#34;Multiple states with terminal condition not supported yet&#34;)

    super().__init__(hp, cfg, bounds, guess, unravel)

  def reinitiate(self, a):
    &#34;&#34;&#34;Helper function for `sequencesolver`
    &#34;&#34;&#34;
    state_shape = self.system.x_0.shape[0]
    control_shape = self.system.bounds.shape[0] - state_shape

    self.x_guess = jnp.vstack((self.system.x_0, jnp.zeros((self.N, state_shape))))
    self.u_guess = jnp.zeros((self.N + 1, control_shape))
    if self.system.adj_T is not None:
      adj_guess = jnp.vstack((jnp.zeros((self.N, state_shape)), self.system.adj_T))
    else:
      adj_guess = jnp.zeros((self.N + 1, state_shape))
    self.adj_guess = index_update(adj_guess, (-1, self.term_cdtion_state), a)

  def solve(self) -&gt; Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:
    &#34;&#34;&#34;Solve the continuous optimal problem with the Forward-Backward Sweep Method&#34;&#34;&#34;
    if self.terminal_cdtion:
      return self.sequencesolver()
    n = 0
    while n == 0 or self.stopping_criterion((self.x_guess, old_x), (self.u_guess, old_u), (self.adj_guess, old_adj)):
      old_u = self.u_guess.copy()
      old_x = self.x_guess.copy()
      old_adj = self.adj_guess.copy()

      self.x_guess = integrate_fbsm(self.system.dynamics, self.x_guess[0], self.u_guess, self.h, self.N,
                                    t=self.t_interval, discrete=self.system.discrete)[-1]
      self.adj_guess = integrate_fbsm(self.system.adj_ODE, self.adj_guess[-1], self.x_guess, -1 * self.h, self.N,
                                      self.u_guess, t=self.t_interval, discrete=self.system.discrete)[-1]

      u_estimate = self.system.optim_characterization(self.adj_guess, self.x_guess, self.t_interval)
      # Use basic convex approximation to update the guess on u
      self.u_guess = 0.5*(u_estimate + old_u)

      n = n + 1

    return self.x_guess, self.u_guess, self.adj_guess

  def sequencesolver(self) -&gt; Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:
    &#34;&#34;&#34;Implement the secant method for the special case where there is a terminal value on some state variables in
    addition to the initial values.
    &#34;&#34;&#34;
    self.terminal_cdtion = False
    count = 0

    # Adjust lambda to the initial guess
    a = self.system.guess_a
    self.reinitiate(a)
    x_a, _, _ = self.solve()
    Va = x_a[-1, self.term_cdtion_state] - self.term_value
    b = self.system.guess_b
    self.reinitiate(b)
    x_b, _, _ = self.solve()
    Vb = x_b[-1, self.term_cdtion_state] - self.term_value

    while jnp.abs(Va) &gt; 1e-10:
      if jnp.abs(Va) &gt; jnp.abs(Vb):
        a, b = b, a
        Va, Vb = Vb, Va

      d = Va*(b-a)/(Vb-Va)
      b = a
      Vb = Va
      a = a - d
      self.reinitiate(a)
      x_a, _, _ = self.solve()
      Va = x_a[-1, self.term_cdtion_state] - self.term_value
      count += 1

    return self.x_guess, self.u_guess, self.adj_guess</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="myriad.optimizers.IndirectMethodOptimizer" href="#myriad.optimizers.IndirectMethodOptimizer">IndirectMethodOptimizer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="myriad.optimizers.FBSM.reinitiate"><code class="name flex">
<span>def <span class="ident">reinitiate</span></span>(<span>self, a)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function for <code>sequencesolver</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reinitiate(self, a):
  &#34;&#34;&#34;Helper function for `sequencesolver`
  &#34;&#34;&#34;
  state_shape = self.system.x_0.shape[0]
  control_shape = self.system.bounds.shape[0] - state_shape

  self.x_guess = jnp.vstack((self.system.x_0, jnp.zeros((self.N, state_shape))))
  self.u_guess = jnp.zeros((self.N + 1, control_shape))
  if self.system.adj_T is not None:
    adj_guess = jnp.vstack((jnp.zeros((self.N, state_shape)), self.system.adj_T))
  else:
    adj_guess = jnp.zeros((self.N + 1, state_shape))
  self.adj_guess = index_update(adj_guess, (-1, self.term_cdtion_state), a)</code></pre>
</details>
</dd>
<dt id="myriad.optimizers.FBSM.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Solve the continuous optimal problem with the Forward-Backward Sweep Method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve(self) -&gt; Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:
  &#34;&#34;&#34;Solve the continuous optimal problem with the Forward-Backward Sweep Method&#34;&#34;&#34;
  if self.terminal_cdtion:
    return self.sequencesolver()
  n = 0
  while n == 0 or self.stopping_criterion((self.x_guess, old_x), (self.u_guess, old_u), (self.adj_guess, old_adj)):
    old_u = self.u_guess.copy()
    old_x = self.x_guess.copy()
    old_adj = self.adj_guess.copy()

    self.x_guess = integrate_fbsm(self.system.dynamics, self.x_guess[0], self.u_guess, self.h, self.N,
                                  t=self.t_interval, discrete=self.system.discrete)[-1]
    self.adj_guess = integrate_fbsm(self.system.adj_ODE, self.adj_guess[-1], self.x_guess, -1 * self.h, self.N,
                                    self.u_guess, t=self.t_interval, discrete=self.system.discrete)[-1]

    u_estimate = self.system.optim_characterization(self.adj_guess, self.x_guess, self.t_interval)
    # Use basic convex approximation to update the guess on u
    self.u_guess = 0.5*(u_estimate + old_u)

    n = n + 1

  return self.x_guess, self.u_guess, self.adj_guess</code></pre>
</details>
</dd>
<dt id="myriad.optimizers.FBSM.sequencesolver"><code class="name flex">
<span>def <span class="ident">sequencesolver</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the secant method for the special case where there is a terminal value on some state variables in
addition to the initial values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sequencesolver(self) -&gt; Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:
  &#34;&#34;&#34;Implement the secant method for the special case where there is a terminal value on some state variables in
  addition to the initial values.
  &#34;&#34;&#34;
  self.terminal_cdtion = False
  count = 0

  # Adjust lambda to the initial guess
  a = self.system.guess_a
  self.reinitiate(a)
  x_a, _, _ = self.solve()
  Va = x_a[-1, self.term_cdtion_state] - self.term_value
  b = self.system.guess_b
  self.reinitiate(b)
  x_b, _, _ = self.solve()
  Vb = x_b[-1, self.term_cdtion_state] - self.term_value

  while jnp.abs(Va) &gt; 1e-10:
    if jnp.abs(Va) &gt; jnp.abs(Vb):
      a, b = b, a
      Va, Vb = Vb, Va

    d = Va*(b-a)/(Vb-Va)
    b = a
    Vb = Va
    a = a - d
    self.reinitiate(a)
    x_a, _, _ = self.solve()
    Va = x_a[-1, self.term_cdtion_state] - self.term_value
    count += 1

  return self.x_guess, self.u_guess, self.adj_guess</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="myriad.optimizers.IndirectMethodOptimizer" href="#myriad.optimizers.IndirectMethodOptimizer">IndirectMethodOptimizer</a></b></code>:
<ul class="hlist">
<li><code><a title="myriad.optimizers.IndirectMethodOptimizer.bounds" href="#myriad.optimizers.IndirectMethodOptimizer.bounds">bounds</a></code></li>
<li><code><a title="myriad.optimizers.IndirectMethodOptimizer.cfg" href="#myriad.optimizers.IndirectMethodOptimizer.cfg">cfg</a></code></li>
<li><code><a title="myriad.optimizers.IndirectMethodOptimizer.guess" href="#myriad.optimizers.IndirectMethodOptimizer.guess">guess</a></code></li>
<li><code><a title="myriad.optimizers.IndirectMethodOptimizer.hp" href="#myriad.optimizers.IndirectMethodOptimizer.hp">hp</a></code></li>
<li><code><a title="myriad.optimizers.IndirectMethodOptimizer.require_adj" href="#myriad.optimizers.IndirectMethodOptimizer.require_adj">require_adj</a></code></li>
<li><code><a title="myriad.optimizers.IndirectMethodOptimizer.stopping_criterion" href="#myriad.optimizers.IndirectMethodOptimizer.stopping_criterion">stopping_criterion</a></code></li>
<li><code><a title="myriad.optimizers.IndirectMethodOptimizer.unravel" href="#myriad.optimizers.IndirectMethodOptimizer.unravel">unravel</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="myriad" href="index.html">myriad</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="myriad.optimizers.get_optimizer" href="#myriad.optimizers.get_optimizer">get_optimizer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="myriad.optimizers.TrajectoryOptimizer" href="#myriad.optimizers.TrajectoryOptimizer">TrajectoryOptimizer</a></code></h4>
<ul class="">
<li><code><a title="myriad.optimizers.TrajectoryOptimizer.solve" href="#myriad.optimizers.TrajectoryOptimizer.solve">solve</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="myriad.optimizers.IndirectMethodOptimizer" href="#myriad.optimizers.IndirectMethodOptimizer">IndirectMethodOptimizer</a></code></h4>
<ul class="">
<li><code><a title="myriad.optimizers.IndirectMethodOptimizer.stopping_criterion" href="#myriad.optimizers.IndirectMethodOptimizer.stopping_criterion">stopping_criterion</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="myriad.optimizers.TrapezoidalCollocationOptimizer" href="#myriad.optimizers.TrapezoidalCollocationOptimizer">TrapezoidalCollocationOptimizer</a></code></h4>
</li>
<li>
<h4><code><a title="myriad.optimizers.HermiteSimpsonCollocationOptimizer" href="#myriad.optimizers.HermiteSimpsonCollocationOptimizer">HermiteSimpsonCollocationOptimizer</a></code></h4>
</li>
<li>
<h4><code><a title="myriad.optimizers.MultipleShootingOptimizer" href="#myriad.optimizers.MultipleShootingOptimizer">MultipleShootingOptimizer</a></code></h4>
</li>
<li>
<h4><code><a title="myriad.optimizers.FBSM" href="#myriad.optimizers.FBSM">FBSM</a></code></h4>
<ul class="">
<li><code><a title="myriad.optimizers.FBSM.reinitiate" href="#myriad.optimizers.FBSM.reinitiate">reinitiate</a></code></li>
<li><code><a title="myriad.optimizers.FBSM.solve" href="#myriad.optimizers.FBSM.solve">solve</a></code></li>
<li><code><a title="myriad.optimizers.FBSM.sequencesolver" href="#myriad.optimizers.FBSM.sequencesolver">sequencesolver</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>