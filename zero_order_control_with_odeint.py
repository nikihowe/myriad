# -*- coding: utf-8 -*-
"""Zero-order control with odeint.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Jkbh77Euenxt89YYKKsNCgq9pzl9NsOP
"""

import jax.numpy as np
from jax import grad
import matplotlib.pyplot as plt
from jax.experimental.ode import odeint
from jax.flatten_util import ravel_pytree
import jax.random as rd

# Make a new dynamics function which remembers which dynamics we passed to it
def make_dynamics_from_controls(us : np.ndarray):

  def dynamics_fun(x : float, t : float):
    # Do something with x and us here. This is just a dummy example which
    # uses the value of the most recent past control.
    cur_time = np.floor(t).astype(np.int32)
    return us[cur_time]

  return dynamics_fun

x_0 = 0.
final_time = 9
key = rd.PRNGKey(42) # change me to get different results
us = rd.uniform(key, shape=(10,))

# Try doing the integration with 10 timesteps
times = np.linspace(0, final_time, 10)
pure_dynamics_fun = make_dynamics_from_controls(us)
xs = odeint(pure_dynamics_fun, y0=x_0, t=times)

# Try doing the integration with 100 timesteps
times = np.linspace(0, final_time, 100)
pure_dynamics_fun = make_dynamics_from_controls(us)
xxs = odeint(pure_dynamics_fun, y0=x_0, t=times)

# Plot the controls and the integrated function
plt.plot([i for i in range(final_time+1)], xs, 'o', label="10 timesteps")
plt.plot([i/11 for i in range(10*(final_time+1))], xxs, '.', label="100 timesteps")
plt.step([i for i in range(final_time + 1)], us, where="post", label="control")
plt.xticks(np.arange(0, 10, step=1))  # Set label locations.
plt.grid()
plt.legend(loc="center right")
plt.show()

