# -*- coding: utf-8 -*-
"""Variable-Control jax + SciPy Cartpole Multiple Shooting.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FYf7nfTEA2XdsluqXIRq-rNX_yYfGeLg

This is an implementation of multiple shooting. It allows an arbitrary number of control values per shooting interval (minimum of 1).

Developed from the Multiple Shooting [Notebook](https://colab.research.google.com/drive/1R5kdLeiMxCDPbGJCFDgcBrLqc8ncTMpt?usp=sharing) which only allows one control per shooting interval.
"""

import numpy as onp
from scipy.optimize import minimize

import jax
import jax.numpy as np
from jax import jit, vmap, lax
from jax.flatten_util import ravel_pytree

from jax.config import config
config.update("jax_enable_x64", True)

horizon = 2                                                    # how many unit time we simulate for
num_shooting_intervals = 20                                    # number of intervals for multiple shooting
num_shooting_interval_edges = num_shooting_intervals + 1      # number of interval edges
num_controls_per_interval = 5                                  # how many intervals of control per shooting interval
shooting_interval_size = horizon / num_shooting_intervals      # how long is each shooting interval
step_size = shooting_interval_size / num_controls_per_interval # how long to hold each control value

############################
# State and Control Bounds #
############################

dist = 0.8
umax = 100

state_bounds = onp.empty((num_shooting_intervals, 8))
# list of tuples, where each variable is a single scalar
# it's a grid, because each row is the state vector at that time step
# horizontal axis is 2x the number of variables in the state
state_bounds[:, 0] = -2*dist # sets first  column to -2*dist
state_bounds[:, 1] = 2*dist  # sets second column to +2*dist

state_bounds[:, 2] = -2*onp.pi # then -2pi
state_bounds[:, 3] = 2*onp.pi  # and  +2pi

state_bounds[:, 4] = -onp.inf # velocity constraint
state_bounds[:, 5] = onp.inf

state_bounds[:, 6] = -onp.inf # angular velocity constraint
state_bounds[:, 7] = onp.inf

# State is (dist, angle, dot(dist), dot(angle))
x0 = np.asarray([0., 0., 0., 0.])
xf = np.asarray([dist, np.pi, 0., 0.])

# Starting state
# (Ending state requirement is handled by equality constraints)
state_bounds[0, :] = 0.

print("state bounds", state_bounds.shape)

control_bounds = onp.empty((num_shooting_intervals * num_controls_per_interval, 2))
control_bounds[:] = [-umax, umax]

print("control bounds", control_bounds.shape)

all_bounds = onp.vstack((onp.reshape(state_bounds, (-1, 2)),
                        control_bounds))

print("all bounds", all_bounds.shape)

################################
# Starting states and controls #
################################

# gives [0., 0.05, 0.1, ..., 0.9, 0.95]
linear_interpolation = onp.linspace(0., 1., num_shooting_interval_edges)[:-1]

# gives 20 rows of [0.8, pi, 0., 0.]
initial_states = onp.tile(onp.array([dist, onp.pi, 0, 0]),
                          (num_shooting_intervals, 1))

# multiply the above two, with broadcasting, to give
# (there are 20 timesteps, so 20 entries)
# [[0.   * 0.8, 0.   * pi, 0.   * 0., 0.   * 0.]
#  [0.05 * 0.8, 0.05 * pi, 0.05 * 0., 0.05 * 0.]
#  ...
#  [0.95 * 0.8, 0.95 * pi, 0.95 * 0., 0.95 * 0.]]
# it's a linear interpolation in state between where we start and one before where we end
initial_states = linear_interpolation[:, onp.newaxis] * initial_states

# So the start state is automatically initialized to (0,0,0,0)
print("initial states", initial_states.shape)

# a tuple, with (initial states, [0]*20)
initial_controls = onp.zeros(num_shooting_intervals * num_controls_per_interval)

print("initial controls", initial_controls.shape)

initial_variables = (initial_states, initial_controls)

# flattens the initial variables into a big list
first_guess_xs_and_initial_controls, unravel = ravel_pytree(initial_variables)

print("(flattened) first state and control guess", first_guess_xs_and_initial_controls.shape)

mc      = 2.
mp      = 0.5
length  = 0.5
gravity = 9.81

# Dynamics Function
# Given state and control, returns velocities and accelerations
@jit
def f(state, control):
  _, theta, x_vel, theta_vel = state
  # Page 868 of tutorial
  x_accel = (
    1/(mc + mp*(np.sin(theta)**2))
    * (
        control + mp*np.sin(theta)
        * (length*(theta_vel**2) + gravity*np.cos(theta))
    )
  )
  # Page 869 of tutorial
  theta_accel = (
    1/(length*(mc + mp*(np.sin(theta)**2)))
    * (-control*np.cos(theta) - mp*length*(theta_vel**2)*np.cos(theta)*np.sin(theta) - (mc + mp)*gravity*np.sin(theta))
  )
  return np.asarray([x_vel, theta_vel, x_accel, theta_accel])

# Instantaneous cost
@jit
def c(x, u):
  return u**2

# Cost over entire (states, controls) trajectory
vector_c = jit(vmap(c))

# Integrate from the very start state, using controls, to the very final state
@jit
def integrate_fwd(us):
  def rk4_step(x, u):
    k1 = f(x, u)
    k2 = f(x + step_size * k1/2, u)
    k3 = f(x + step_size * k2/2, u)
    k4 = f(x + step_size * k3  , u)
    return x + (step_size/6)*(k1 + 2*k2 + 2*k3 + k4)

  def fn(carried_state, u):
    one_step_forward = rk4_step(carried_state, u)
    return one_step_forward, one_step_forward # (carry, y)

  last_state, all_next_xs = lax.scan(fn, x0, us)
  return last_state, all_next_xs

@jit
def integrate_shooting_interval(start_x, interval_us):
  def rk4_step(x, u):
    k1 = f(x, u)
    k2 = f(x + step_size * k1/2, u)
    k3 = f(x + step_size * k2/2, u)
    k4 = f(x + step_size * k3  , u)
    return x + (step_size/6)*(k1 + 2*k2 + 2*k3 + k4)

  def fn(carried_state, u):
    one_step_forward = rk4_step(carried_state, u)
    return one_step_forward, one_step_forward # (carry, y)

  last_interval_state, all_next_states = lax.scan(fn, start_x, interval_us)
  return last_interval_state, all_next_states

# Step all startign states through their shooting intervals
parallel_shooting_step = jit(vmap(integrate_shooting_interval))

# Calculate cost over entire trajectory
@jit
def objective(starting_xs_and_current_us):
  _, us = unravel(starting_xs_and_current_us)
  _, xs = integrate_fwd(us)                 # integrates from start state through to the end
  all_costs = vector_c(xs, us)              # calculate cost from states and controls
  return np.sum(all_costs) + np.dot(x0, x0) # add in cost of start state (will make no difference)

# Calculate defect of intermediate and final states
@jit
def equality_constraints(starting_xs_and_current_us):
  starting_xs, us = unravel(starting_xs_and_current_us)
  predicted_next_states, _ = parallel_shooting_step(
      starting_xs, us.reshape(num_shooting_intervals, num_controls_per_interval))
  ending_xs = np.concatenate((starting_xs[1:], xf[np.newaxis]))
  return np.ravel(predicted_next_states - ending_xs) # we must flatten this to get dimensions to match up

constraints = ({'type': 'eq',
                'fun': equality_constraints,
                'jac': jax.jit(jax.jacrev(equality_constraints))
                })

options = {'maxiter': 500, 'ftol': 1e-6}

solution = minimize(fun=objective,
                    x0=first_guess_xs_and_initial_controls,
                    method='SLSQP',
                    constraints=constraints,
                    bounds=all_bounds,
                    jac=jax.jit(jax.grad(objective)),
                    options=options)
if solution.success:
  print("Success")
else:
  print(solution)

opt_values = solution.x

import matplotlib.pyplot as plt

# Prepare to plot the controls at the knot points
opt_states, opt_controls = unravel(solution.x)
knot_controls = []
for i, u in enumerate(opt_controls):
  if i % num_controls_per_interval == 0:
    knot_controls.append(u)
knot_times = onp.linspace(0, horizon, num_shooting_intervals+1)[:-1]

fig = plt.figure()
ax = fig.add_subplot(1, 1, 1)
time_axis = [horizon/(num_shooting_intervals * num_controls_per_interval)*k
             for k in range(num_shooting_intervals * num_controls_per_interval)]
ax.step(time_axis, opt_controls, where="post", label="optimal controls")
# ax.plot(knot_times, knot_controls, 'x', label="knot points")
ax.grid()
plt.xticks(onp.arange(0, 2, step=0.5))
plt.legend()
plt.show()

print(opt_controls)

opt_controls.shape

